

# Deploying Faust DSP on the Web

Using developments done for the Web (WebAssembly backends and **libfaust** library compiled in WebAssembly with [Emscripten](https://emscripten.org)), statically and dynamically Faust generated WebAudio nodes can be easily produced and deployed on the Web. 

The **Faust Web Audio Library** has been completely rewriten in TypeScript and is distributed as an [npm package](https://www.npmjs.com/package/@grame/libfaust), to be used in TypeScript written applications.  An alternative is to use the JavaScript version of the TypeScript source available as the `FaustLibrary.js` JavaScript library. 

This library can be used to load WebAudio nodes created from Faust DSP code (precompiled to WebAssembly), or in conjunction with `libfaust-wasm.js` libray (the WebAssembly version of the **libfaust** library) containing the compiler, it can be used to dynamically compile and deploy Faust DSP based WebAudio nodes.

## Deploying statically compiled Faust WebAudio nodes

From a **foo.dsp** source file, a JSON and WebAssembly files can be produced with the following script:

    faust2wasm foo.dsp 

The compiler generates a **foo.wasm** file with the WebAssembly module as binary code and a **foo.json** file, and `faust2wasm` creates and additional loader **foo.js** file that will use code in FaustLibrary.js to create a WebAudio node (using an extended **AudioWorkletNode** node if supported or using the old **ScriptProcessor** model if needed). The name of the Faust DSP code file is used to define the final **AudioWorkletNode** constructor name. So for instance if **osc.dsp** file is compiled, the **Faustosc** class will be generated and can be used the following way:

```
// Create the Faust generated node
var factory_url = ".";
var factory = new Faustosc(audio_context, factory_url);
factory.create().then(node => {....});
```

The resulting node is an extended AudioWorkletNode, to be used as a regular node (like connected to other WebAudio nodes), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node:

    var paths = node.getParams(); // get the set of paths to read/write input control parameters

Then knowing the path for a given parameter, the following function is used to change the parameter value:

    node.setParamValue("/Oscillator/freq", 0.6);

A full JSON description of the node with the complete UI, can be retrieved with:  

    var json = node.getJSON(); 

To properly deallocate ressources at the end of its life, be sure to call the `destroy` function on the node. Use `faust2wasm -h` to see all available options.

### A simple example Web page

A simple Web page using the files generated by **faust2wasm** on the **noise.dsp** file can be defined with the following parts:

```
<!-- Load 'faust2wasm' script generated .js file -->
<script src="noise.js"></script>
<!-- Load the Faust JS library -->
<script src="FaustLibrary.js"></script> 
```

A slider to control the noise volume parameter is defined with:

```
<P> Noise volume:
<input type="range" oninput="changeVolume(event) "min="0" max="1" value="0.5" step="0.01"/>
```

The WebAudio context is created and the noise slide hander is defined with:

```
var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();
var noise_dsp = null;

// Slider handler to change the 'noise' volume
function changeVolume(event) {
    noise_dsp.setParamValue("/Noise/Volume", parseFloat(event.target.value));
}
```

A **startnoise** function which creates the Faust WebAudio node is defined with:

```
function startnoise() {
    // Create the Faust generated node
    var factory_url = ".";
    var factory = new Faustnoise(audio_context, factory_url);
    factory.create().then(node => {
        noise_dsp = node;
        console.log(noise_dsp.getJSON());
        // Print path to be used with 'setParamValue'
        console.log(noise_dsp.getParams());
        // Connect it to output as a regular WebAudio node
        noise_dsp.connect(audio_context.destination);
    });
}
```

An finally the load handler is defined to activate the code:

    window.addEventListener("load", startnoise);

Look at the [Noise](noise-wasm.html) and [OSC](osc-wasm.html) pages for the complete code. 

Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the *python -m SimpleHTTPServer* command for instance) and access them with their *http://* based URL.  


### Generating Polyphonic WebAudio nodes

Assuming that the compiled Faust DSP file is [polyphonic ready](https://faustdoc.grame.fr/manual/midi/#midi-polyphony-support), a polyphonic ready WebAudio node can be created by adding the *-poly* option:

    faust2wasm -poly organ.dsp 

and will generate the **FaustorganPoly** class for the node, to be used like: 


```
// Create the Faust generated node with 16 voices
var factory_url = ".";
var factory = new FaustorganPoly(audio_context, 16, factory_url);
factory.create().then(node => {....});
```

Polyphonic nodes have an extended API to be controled with MIDI messages: 

```
/**
* Instantiates a new polyphonic voice. 
*
* @param channel - the MIDI channel (0..15, not used for now)
* @param pitch - the MIDI pitch (0..127)
* @param velocity - the MIDI velocity (0..127)
*/
keyOn = function(channel, pitch, velocity) {...}
```

```
/**
* De-instantiates a polyphonic voice. 
*
* @param channel - the MIDI channel (0..15, not used for now)
* @param pitch - the MIDI pitch (0..127)
* @param velocity - the MIDI velocity (0..127)
*/
keyOff = function(channel, pitch, velocity) {...}
```

```
/**
* Gently terminates all the active voices.
*/
allNotesOff = function() {...}
````

Look at the [Organ](organ-wasm.html) page for the complete code. Look at the JavaScript public documentation section for the complete description. 


## Deploying WebAudio Plugins (WAP)

The [WebAudio Plugins](https://github.com/micbuffa/WebAudioPlugins) is a plugin format currently developed by a group of researchers and developers. Faust DSP code can be directly compiled for it using the *-wap* parameter, like this: 

    faust2wasm -wap osc.dsp 

In this case a generic **main.js** file is created (which will load a **osc.wasm** file), a **main.json** file to describe the plugin, and an **index.html** file to test it.

## Generating fully working self-contained HTML pages

The **faust2webaudiowasm** script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the **osc.dsp** Faust DSP source file, it will generate an **osc.html** file:

    faust2webaudiowasm osc.dsp

Assuming that the compiled Faust DSP file is polyphonic ready, the *-poly* parameter can be used to generate a polyphonic MIDI controllable instrument, to be used with a MIDI application or device. Use `faust2webaudiowasm -h` to see all available options.


## Deploying dynamically compiled Faust WebAudio nodes

Since the **libfaust** library has been compiled for the Web, it becomes possible to **embed the complete dynamic compilation chain in a Web page**, from the Faust DSP source to the executable WebAudio node. 

First the following resources (located on the Faust GitHub in architecture/webaudio folder) have to be loaded in the page:

```
<!-- Load 'libfaust' library and wrapper code -->
<script src="libfaust-wasm.js"></script>
<!-- Load the Faust JS library -->
<script src="FaustLibrary.js"></script> 
```

#### Using the lower-level API

The **FaustModule** global is a promise defined in `FaustLibrary.js` file, that returns a Faust Wasm module when the code is ready. So something like the following lines has to be written, when `init` will typically create DSP factories, either monophonic or polyphonic ones:

```
FaustModule().then((module) => { init(module); });

function init(module) {
    // Init Faust compiler and node factory 
    var faust_compiler = Faust.createCompiler(Faust.createLibFaust(module));
    var faust_mono_factory = Faust.createMonoFactory();
    var faust_poly_factory = Faust.createPolyFactory();
    ....
}
```

The  following function is used to generate a *monophonic* node from a monophonic factory, here is the TypeScript prototype:

```
/**
* Create a monophonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).
* Note that an internal cache avoids recompilation when a same DSP program is recompiled several times.
*
* @param {BaseAudioContext} context the WebAudio context
* @param {string} name - the DSP name
* @param {Factory} factory - the Faust factory, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)
* @param {boolean} sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode
* @param {number} buffer_size - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames
* @preturn {Promise<FaustMonoNode | null>} the compiled WebAudio node or 'null' if failure
*/
createNode(context: BaseAudioContext,
            name: string,
            factory: Factory,
            sp: boolean,
            buffer_size?: number)
            : Promise<FaustMonoNode | null>;
```

The  following function is used to generate a *polyphonic* node from a polyphonic factory, here is the TypeScript prototype:

```
/**
* Create a polyphonic WebAudio node (either ScriptProcessorNode or AudioWorkletNode).
* Note that an internal cache avoids recompilation when a same DSP program is recompiled several times.
*
* @param {BaseAudioContext} context the WebAudio context
* @param {string} name - the DSP name
* @param {Factory} voice_factory - the Faust factory for voices, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory)
* @param {WebAssembly.Module} mixer_module - the wasm Mixer module (loaded from 'mixer32.wasm' or 'mixer64.wasm' files)
* @param {number} voices - the number of voices
* @param {boolean} sp - whether to compile a ScriptProcessorNode or an AudioWorkletNode
* @param {Factory} effect_factory - the Faust factory for the effect, either obtained with a compiler (createDSPFactory) or loaded from files (loadDSPFactory) 
* @param {number} buffer_size - the buffer size in frames to be used in ScriptProcessorNode only, since AudioWorkletNode always uses 128 frames
* @preturn {Promise<FaustPolyNode | null>} the compiled WebAudio node or 'null' if failure
*/
createNode(context: BaseAudioContext,
            name: string,
            voice_factory: Factory,
            mixer_module: WebAssembly.Module,
            voices: number,
            sp: boolean,
            effect_factory?: Factory,
            buffer_size?: number)
            : Promise<FaustPolyNode | null>;
```

The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones.  Look at the [Dynamic Faust compiler](faustlive-wasm.html) page for a more complete use-case of the dynamic compiler.

#### Using the higher-level API

A higher-level API can be used to simplify some of the previously described steps, using the multi-purpose **compileAudioNode** function  (here is the TypeScript prototype):


```
/**
* Compiles a WebAudio node from its DSP code.
*
* @param {BaseAudioContext} context the WebAudio context
* @param {FaustModule} module - the Faust module as given by an async FaustModule() call
* @param {string} dsp_code - the Faust dsp code (may contain an integrated effect)
* @param {string | null} effect_code - optional effect DSP code, that can be used in place of the integrated effect model
* @param {number} voices - the number of voices. When voices = 0, a monophonic node is created, otherwise a polyphonic one
* @preturn {Promise<FaustMonoNode | FaustPolyNode | null>} the compiled WebAudio node or 'null' in case of failure
*/
function compileAudioNode(audioCtx: BaseAudioContext, module: FaustModule, dsp_code: string, effect_code: string | null, voices: number): Promise<FaustMonoNode | FaustPolyNode | null>
```

A monophonic can directly be created written with:

```
var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();

var dsp_code = "import(\"stdfaust.lib\"); vol = hslider(\"volume [unit:dB]\", 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\"freq [unit:Hz]\", 1000, 20, 24000, 1); process = vgroup(\"Oscillator\", os.osc(freq) * vol);";

var osc_dsp = null;

// Load handler which call 'startosc' when 'libfaust-wasm.js' is properly loaded
FaustModule().then((module) => { startosc(module); });

async function startosc(module) {

    // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code'
    osc_dsp = await Faust.compileAudioNode(audio_context, module, dsp_code, null, 0);

    // Print DSP JSON																				
    console.log(osc_dsp.getJSON());
    // Print paths to be used with 'setParamValue'
    console.log(osc_dsp.getParams());
    // Connect it to output as a regular WebAudio node
    osc_dsp.connect(audio_context.destination);
}
```

A polyphonic node can directly be created written with:

```
var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();
var dsp_code_url = "http://127.0.0.1:8000/organ.dsp";

// Load handler which call 'startorgan' when 'libfaust-wasm.js' is properly loaded
FaustModule().then((module) => { startorgan(module); });

async function startorgan(module) {

    var dsp_file = await fetch(dsp_code_url);
    var dsp_code = await dsp_file.text();

    // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code'
    organ_dsp = await Faust.compileAudioNode(audio_context, module, dsp_code, null, 16);

    // Print DSP JSON	
    console.log(organ_dsp.getJSON());
    // Print paths to be used with 'setParamValue'
    console.log(organ_dsp.getParams());
    // Connect it to output as a regular WebAudio node
    organ_dsp.connect(audio_context.destination);
    // Activate MIDI
    activateMIDIInput();
}
```

The [Dynamic OSC](dynamic-osc-worklet-wasm.html) page demonstrates the dynamic OSC complete code (based on the example seen before). The [Dynamic Organ](dynamic-organ-worklet-wasm.html) page demonstrates a polyphonic organ instrument, which loads a DSP from an url, and ready to be controlled with a MIDI device or application. 

Note that the **compileAudioNode** automatically adds the *-ftz 2* compilation option (see next section), and create the node in AudioWorklet mode if supported.

## Float denormal handling

A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. 

Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the *-ftz* compilation parameter must be used at compilation time. 

The *-ftz 1* mode adds a test in each recursive loop which uses the *fabs* function and a threshold to detect subnormal samples (slower). The *-ftz 2* mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). 

Use for example the following line to active software denormal handing when using **faust2wasm** tool:

    faust2wasm -ftz 2 foo.dsp 

The same for the **faust2webaudiowasm** tool:

    faust2webaudiowasm -ftz 2 foo.dsp 

For dynamic compilation, the *-ftz v* flag will have to be added in the *argv* parameter in **compileMonoNode** or **compilePolyNode** functions.

